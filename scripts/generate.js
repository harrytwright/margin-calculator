/**
 * This to automatically create the interface files with `Selectable`, `Insertable`, and `Updateable`
 * wrapping, mainly since it's an extra step I have to do, might as well make the code do it for me
 *
 * lol
 *
 * Completed: Maybe create the JSON* interfaces next from an openapi schema
 * Todo: Clean this up a lot
 * */

const path = require('path')
const fs = require('fs/promises')

const banner = `
/* eslint-disable */

/**
 * This file was automatically generated by @lanelink/tools
 *
 * Using \`json-schema-to-typescript\`, \`@redocly/openapi-core\` and \`prisma-kysely\`.
 *
 * DO NOT MODIFY IT BY HAND. Instead, modify the openapi schemas or the \`prisma.schema\`
 * and re-run \`@lanelink/tools generate\` to regenerate this file
 * */
 `.trimStart()

async function main() {
  try {
    await handleDatabaseSchema(
      path.join(process.cwd(), './src/datastore/types.ts')
    )
  } catch (err) {
    console.error(err)
    return Promise.reject(err)
  }
}

main()
  .then((files) => {
    console.log('Completed with %s exit', 0)
  })
  .catch((err) => {
    console.error(err)
    process.exit(1)
  })

async function handleDatabaseSchema(filePath) {
  const ts = require('typescript')

  // Build a program using the set of root file names in fileNames
  const program = ts.createProgram([filePath], {
    target: ts.ScriptTarget.ES5,
    module: ts.ModuleKind.CommonJS,
  })

  const types = []

  // Visit every sourceFile in the program
  for (const sourceFile of program.getSourceFiles()) {
    if (!sourceFile.isDeclarationFile) {
      // Walk the tree to search for classes
      ts.forEachChild(sourceFile, visit)
    }
  }

  const dir = path.join(process.cwd(), './src/interfaces/database')
  try {
    await fs.mkdir(dir)
  } catch (err) {
    await fs.rm(dir, { force: true, recursive: true })
    await fs.mkdir(dir, { recursive: true })
  }

  for (const type of types) {
    const file = ts.createSourceFile(
      path.join(dir, `${type.replaceAll('_', '-')}.interface.ts`),
      '',
      ts.ScriptTarget.ESNext,
      false,
      ts.ScriptKind.TS
    )
    const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed })

    const isUpperCase = type[0] === type[0].toUpperCase()
    const lowercasedType = lowercaseFirstLetter(type)

    const importArgs = [
      isUpperCase ? ts.factory.createIdentifier(type) : undefined,
      ts.factory.createIdentifier(isUpperCase ? lowercasedType : type),
    ]

    const reference = isUpperCase
      ? ts.factory.createIdentifier(lowercasedType)
      : ts.factory.createIdentifier(type)

    const source = ts.factory.createSourceFile(
      [
        ts.factory.createImportDeclaration(
          undefined,
          ts.factory.createImportClause(
            true,
            undefined,
            ts.factory.createNamedImports([
              ts.factory.createImportSpecifier(
                false,
                undefined,
                ts.factory.createIdentifier('Selectable')
              ),
              ts.factory.createImportSpecifier(
                false,
                undefined,
                ts.factory.createIdentifier('Insertable')
              ),
              ts.factory.createImportSpecifier(
                false,
                undefined,
                ts.factory.createIdentifier('Updateable')
              ),
            ])
          ),
          ts.factory.createStringLiteral('kysely'),
          undefined
        ),
        ts.factory.createImportDeclaration(
          undefined,
          ts.factory.createImportClause(
            true,
            undefined,
            ts.factory.createNamedImports([
              ts.factory.createImportSpecifier(false, ...importArgs),
            ])
          ),
          ts.factory.createStringLiteral(path.relative(dir, filePath)),
          undefined
        ),
        ts.factory.createIdentifier('\n'),
        ts.factory.createTypeAliasDeclaration(
          [ts.factory.createToken(ts.SyntaxKind.ExportKeyword)],
          ts.factory.createIdentifier(
            `${capitalizeFirstLetter(camelCase(type))}`
          ),
          undefined,
          ts.factory.createTypeReferenceNode(
            ts.factory.createIdentifier('Selectable'),
            [ts.factory.createTypeReferenceNode(reference, undefined)]
          )
        ),
        ts.factory.createTypeAliasDeclaration(
          [ts.factory.createToken(ts.SyntaxKind.ExportKeyword)],
          ts.factory.createIdentifier(
            `New${capitalizeFirstLetter(camelCase(type))}`
          ),
          undefined,
          ts.factory.createTypeReferenceNode(
            ts.factory.createIdentifier('Insertable'),
            [ts.factory.createTypeReferenceNode(reference, undefined)]
          )
        ),
        ts.factory.createTypeAliasDeclaration(
          [ts.factory.createToken(ts.SyntaxKind.ExportKeyword)],
          ts.factory.createIdentifier(
            `Update${capitalizeFirstLetter(camelCase(type))}`
          ),
          undefined,
          ts.factory.createTypeReferenceNode(
            ts.factory.createIdentifier('Updateable'),
            [ts.factory.createTypeReferenceNode(reference, undefined)]
          )
        ),
        ts.factory.createIdentifier('\n'),
        ts.factory.createTypeAliasDeclaration(
          [ts.factory.createToken(ts.SyntaxKind.ExportKeyword)],
          ts.factory.createIdentifier(
            `${capitalizeFirstLetter(camelCase(type))}InsertTypes`
          ),
          undefined,
          ts.factory.createUnionTypeNode([
            ts.factory.createTypeReferenceNode(
              ts.factory.createIdentifier(
                `New${capitalizeFirstLetter(camelCase(type))}`
              ),
              undefined
            ),
            ts.factory.createTypeReferenceNode(
              ts.factory.createIdentifier(
                `Update${capitalizeFirstLetter(camelCase(type))}`
              ),
              undefined
            ),
          ])
        ),
      ],
      ts.factory.createToken(ts.SyntaxKind.EndOfFileToken),
      ts.NodeFlags.None
    )

    const result = printer.printNode(ts.EmitHint.Unspecified, source, file)
    await fs.writeFile(file.fileName, `${banner}\n${result}`)
  }

  const sourceFile = ts.createSourceFile(
    path.join(dir, `index.ts`),
    '',
    ts.ScriptTarget.ESNext,
    false,
    ts.ScriptKind.TS
  )

  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed })

  const source = ts.factory.createSourceFile(
    types.map((type) =>
      ts.factory.createExportDeclaration(
        undefined,
        false,
        undefined,
        ts.factory.createIdentifier(
          `'./${type.replaceAll('_', '-')}.interface'`
        )
      )
    ),
    ts.factory.createToken(ts.SyntaxKind.EndOfFileToken),
    ts.NodeFlags.None
  )

  const result = printer.printNode(ts.EmitHint.Unspecified, source, sourceFile)
  await fs.writeFile(sourceFile.fileName, `${banner}\n${result}`)

  /** visit nodes finding exported classes */
  function visit(node) {
    // Only consider exported nodes
    if (!isNodeExported(node)) {
      return
    }

    if (
      ts.isTypeAliasDeclaration(node) &&
      node.name &&
      node.name.escapedText === 'DB'
    ) {
      for (const member of node.type.members) {
        if (!ts.isPropertySignature(member)) break

        types.push(member.type.typeName.escapedText)
      }
    }
  }

  /** True if this is visible outside this file, false otherwise */
  function isNodeExported(node) {
    return (
      (ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export) !== 0 ||
      (!!node.parent && node.parent.kind === ts.SyntaxKind.SourceFile)
    )
  }
}

function camelCase(str, { upperCase = false } = {}) {
  if (str.length === 0) {
    return str
  }

  if (upperCase && isAllUpperCaseSnakeCase(str)) {
    // Only convert to lower case if the string is all upper
    // case snake_case. This allows camelCase strings to go
    // through without changing.
    str = str.toLowerCase()
  }

  let out = str[0]

  for (let i = 1, l = str.length; i < l; ++i) {
    const char = str[i]
    const prevChar = str[i - 1]

    if (char !== '_') {
      if (prevChar === '_') {
        out += char.toUpperCase()
      } else {
        out += char
      }
    }
  }

  return out
}

function isAllUpperCaseSnakeCase(str) {
  for (let i = 1, l = str.length; i < l; ++i) {
    const char = str[i]

    if (char !== '_' && char !== char.toUpperCase()) {
      return false
    }
  }

  return true
}

function capitalizeFirstLetter([first = '', ...rest], locale = 'en') {
  return [first.toLocaleUpperCase(locale), ...rest].join('')
}

function lowercaseFirstLetter([first = '', ...rest], locale = 'en') {
  return [first.toLocaleLowerCase(locale), ...rest].join('')
}
